########################
# GHOST - ASCII regex aI
#   ---__m_oo_m__--- ( hello there stranger )
#   ---__m_OO_m__--- ? what is your name ?
#   ---__m_o0_M__=== ! hypersexual name !
##### 2hrs_later ######
#   ...__w00w__... % your tmpmovrd has completed action regex ![0..9]|!(musl) % 
# overworked
#   ...__w00w__... % next already % 
# overworked
#   :::__w--w__::: < night > 
# passout
use ARI::say;                   # output
use ARI::say::internal_io;      # files
use ARI::say::external_io;      # sockets
use ARI::listen;                # input
use ARI::listen::external_io;   # sockets
use ARI::listen::internal_io;   # files
use ARI::personality;           # single_configuration
use ARI::personality::emo;      # datasets
use ARI::cache;                 # single_configuration
use ARI::MKRX;                  # single_configuration
use ARI::stress;                # log status
use ARI::pain;                  # log breaches
use ARI::fulfilled;             # mission progress
use ARI::sitmulation;           # accomplishments of mission
use ARI::opinion;               # user query + entity_queries
use ARI::skill;                 # entity_query if (-e $downtime);
use ARI::soul;                  # sha-verifiable permenant characteristics 
use ARIL::skill::mission;       # projects in downtime + history
############################################
# single_configuration
package ARI::cache;
use proto::nfs;
my $mem = ; # RAM
my $mem_ssd =; # Quick
my $mem_ssd_hdd =; # Local
my $mem_ssd_hdd_nfs =; # Remote
INPUT REACTION
%personality # hashes to quick cache
        %emo_type{$emo_reaction[personality_rand()]}
memory_subject_pointers hash_location
        call

#########################################
use ARI::personality::emo;      # datasets
my $comfortable = '---m_oo_m---';
my $semi_alert = '---m_o0_M~~~';
my $flare = '===M_VV_M===';
my $angry = '---_M_oo_M---';
my $amused = '~~~M_OO_M~~~';
my $busy = '---w_00_w---';

sub emo {
        my $listen = shift;
        reaction($listen);
}
sub reaction {
        my $listen = shift;
        my $past_state = shift;
        my $current_state = shift;
        my $response = ; # i+p+c=r
        return $response;
}

########################################
use ARI::mouth;
use ARI::internal_io;
use ARI::external_io;
my ($reaction) = @ARGV;
my $enaunciation = emo_code($reaction);
my %emo;        # a dataset
$words = %emo{$enaunciation};
print $say "$words\n";  # speak internal/external sockets

sub emo_code {  # uses input of ARI::listen
        my $reaction = shift;
}

######################################
use ARI::external_awareness;
my ($cam, $mic, $speaker, $light, $wireless, $radio, $keyboard);
sub recognition {
}
